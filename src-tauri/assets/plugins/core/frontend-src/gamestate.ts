import type FileheaderEvent_BI from "@elite-dangerous-plugin-framework/journal/dist/generated/Fileheader.bi";
import type LoadoutEvent_BI from "@elite-dangerous-plugin-framework/journal/dist/generated/Loadout.bi";
import {
  makeEddnHeader,
  NoopEddnEmitter,
  RealEddnEmitter,
  type EddnEmitter,
  type LoadGame,
} from "./eddn/eddn";
import type { JournalEvent_BI } from "@elite-dangerous-plugin-framework/journal";
import { extractAndStripJournal } from "./eddn/journal";
import {
  stripDockingDeniedEvent,
  stripDockingGrantedEvent,
} from "./eddn/docking";
import type { EddnPreferencesZod } from "./settings";
import type z from "zod";

/**
 * Generated by the GameState whenever the UI should display something new
 */
export type GameStateData = {
  cmdr: string;
  system?: {
    name: string;
    id: BigInt;
    starPos: Extract<JournalEvent_BI, { event: "Location" }>["StarPos"];
  };
  station?: {
    name: string;
    id: BigInt;
    stationType: string;
    situation:
      | {
          type: "docking";
          pad: BigInt;
        }
      | {
          type: "vicinity";
        }
      | {
          type: "docked";
        };
  };
  vessel?:
    | {
        type: "Ship";
        name: string;
        id: BigInt;
        slef: LoadoutEvent_BI;
      }
    | {
        type: "SRV";
        // TODO
      }
    | {
        type: "OnFoot";
        // TODO
      };
};

/**
 * The gamestate essentially defines the "state" of the game. This is inferred by aggregating all events for a journal.
 * Do note that we turn off EDDN Emitting is on a Legacy Client.
 */
export class GameState {
  // We default to disabled. The GameState must be initialized with the eddn Settings
  #eddnSettings: z.infer<typeof EddnPreferencesZod> = { enabled: false };
  notifyEddnPrefsChanged(eddnPref: z.infer<typeof EddnPreferencesZod>): void {
    console.log({ eddnPref });
    this.#eddnSettings = eddnPref;
  }
  /**
   * The header MUST be present before using EDDN. If this is missing, we reject emitting to EDDN
   */
  #header: FileheaderEvent_BI | undefined;
  #cmdr: string | undefined;
  #eddnEmitter: EddnEmitter = new NoopEddnEmitter();
  #file: string;
  #cb: (ev: GameStateData | undefined, cmdr: string) => void;
  // The internal state. Once we load into the game this gets data
  #state: GameStateData | undefined;
  #loadGame: LoadGame | undefined;

  constructor(
    file: string,
    eventCallback: (ev: GameStateData | undefined, cmdr: string) => void,
    private edpfVersion: string
  ) {
    this.#file = file;
    this.#cb = eventCallback;
  }

  public get file() {
    return this.#file;
  }
  public get cmdr() {
    return this.#cmdr;
  }

  private emit() {
    // we clone here so that the receiver cannot modify the internal state
    const state = structuredClone(this.#state);
    this.#cb(state, this.#cmdr!);
  }

  private handleEvent(ev: JournalEvent_BI, allowEmitToEDDN: boolean) {
    //allowEmitToEDDN is true if, and only if, we are playing "live" data. Replaying the journal to reconcile the state does NOT emit to EDDN
    switch (ev.event) {
      case "Fileheader":
        this.#header = ev;
        // See also: https://github.com/EDCD/EDDN/blob/master/docs/Developers.md#gameversions-and-gamebuild
        // EDPF only serves Live (4.X), for both Odyssey and Horizons
        if (ev.Odyssey === true) {
          // We enable the EDDN Listener
          // TODO: add real URL
          this.#eddnEmitter = new RealEddnEmitter(
            "https://eddn.edcd.io:4430",
            true
          );
        }
        break;
      case "LoadGame":
        this.#loadGame = ev;
        break;
      case "Commander":
        this.#cmdr = ev.Name;
        if (!this.#state) {
          this.#state = {
            cmdr: ev.Name,
          };
        }
        this.emit();
        break;
      case "Location":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        this.#state.system = {
          name: ev.StarSystem,
          id: ev.SystemAddress,
          starPos: ev.StarPos,
        };
        // TODO: use this to determine if we're in Taxi, Docked, Multicrew
        if (ev.MarketID) {
          // We are docked
          this.#state.station = {
            stationType: ev.StationType!,
            situation: { type: "docked" },
            name: ev.StationName!,
            id: ev.MarketID,
          };
        }
        this.emit();
        break;
      case "Loadout":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        this.#state.vessel = {
          type: "Ship",
          id: ev.ShipID,
          name: ev.ShipName,
          slef: ev,
        };
        this.emit();
        break;
      case "FSDJump":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        this.#state.system = {
          name: ev.StarSystem,
          id: ev.SystemAddress,
          starPos: ev.StarPos,
        };
        delete this.#state.station;
        this.emit();
        break;
      case "Undocked":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        if (
          this.#state.station &&
          this.#state.station.situation.type === "docked"
        ) {
          this.#state.station.situation = {
            type: "vicinity",
          };
        }
        this.emit();
        return;
      case "SupercruiseEntry":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        delete this.#state.station;
        this.#state.system = {
          id: ev.SystemAddress,
          name: ev.StarSystem,
          starPos: this.#state.system!.starPos,
        };
        this.emit();
        break;
      case "DockingCancelled":
      case "DockingDenied":
      case "DockingGranted":
      case "Docked":
        if (!this.#state) {
          throw new Error("invalid state");
        }

        let situation: NonNullable<GameStateData["station"]>["situation"] = {
          type: "vicinity",
        };
        if (ev.event === "Docked") {
          situation = {
            type: "docked",
          };
        }
        if (ev.event === "DockingGranted") {
          situation = {
            type: "docking",
            pad: ev.LandingPad,
          };
        }

        this.#state.station = {
          id: ev.MarketID,
          name: ev.StationName,
          stationType: ev.StationType,
          situation,
        };
        this.emit();
        break;
      case "CarrierJump":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        if (ev.Docked) {
          this.#state.system = {
            name: ev.StarSystem,
            id: ev.SystemAddress,
            starPos: ev.StarPos,
          };
          this.emit();
          break;
        }
    }
    // at this point the "internal" state is set. We now handle EDDN (if allowed and preconditions are met)
    if (
      this.#eddnSettings.enabled &&
      allowEmitToEDDN &&
      this.#cmdr &&
      this.#header &&
      this.#loadGame &&
      this.#state?.system
    ) {
      let eddnData:
        | undefined
        | { message: object | undefined; $schemaRef: string };
      const header = makeEddnHeader(this.edpfVersion, this.#cmdr, this.#header);

      switch (ev.event) {
        case "Docked":
        case "FSDJump":
        case "Scan":
        case "Location":
        case "SAASignalsFound":
        case "CarrierJump":
        case "CodexEntry":
          eddnData = {
            message: extractAndStripJournal(
              ev,
              this.#state.system,
              this.#loadGame
            ),
            $schemaRef: "https://eddn.edcd.io/schemas/journal/1" as const,
          };
          break;
        case "DockingDenied":
          eddnData = {
            message: stripDockingDeniedEvent(ev, this.#loadGame),
            $schemaRef: "https://eddn.edcd.io/schemas/dockingdenied/1" as const,
          };
          break;
        case "DockingGranted":
          eddnData = {
            message: stripDockingGrantedEvent(ev, this.#loadGame),
            $schemaRef:
              "https://eddn.edcd.io/schemas/dockinggranted/1" as const,
          };
      }
      if (eddnData && eddnData.message) {
        const entirePayload = {
          message: eddnData.message!,
          $schemaRef: eddnData.$schemaRef,
          header,
        };
        this.#eddnEmitter.emit(entirePayload);
      }
    }
  }

  public notifyAboutEvents(evs: JournalEvent_BI[], allowEmitToEDDN = false) {
    for (const ev of evs) {
      this.handleEvent(ev, allowEmitToEDDN);
    }
  }

  public static fromInitialState(
    evs: JournalEvent_BI[],
    file: string,
    eventCallback: (ev: GameStateData | undefined, cmdr: string) => void,
    edpfVersion: string
  ) {
    const state = new GameState(file, eventCallback, edpfVersion);
    evs.forEach((e) => state.handleEvent(e, false));
    return state;
  }
}
