import {
  makeEddnHeader,
  NoopEddnEmitter,
  RealEddnEmitter,
  type EddnEmitter,
  type LoadGame,
} from "./eddn/eddn";
import type {
  FileheaderEvent_BI,
  FSSSignalDiscoveredEvent_BI,
  JournalEvent_BI,
  LoadoutEvent_BI,
} from "@elite-dangerous-plugin-framework/journal";
import { extractAndStripJournal } from "./eddn/journal";
import {
  stripDockingDeniedEvent,
  stripDockingGrantedEvent,
} from "./eddn/docking";
import type { EddnPreferencesZod } from "./settings";
import type z from "zod";
import { stripApproachSettlementEvent } from "./eddn/approachSettlement";
import {
  stripAndExtractFSSSignalDiscovered,
  stripFssAllBodiesFound,
  stripFssBodySignals,
  stripFssDiscoveryScan,
} from "./eddn/scanning";

/**
 * Generated by the GameState whenever the UI should display something new
 */
export type GameStateData = {
  cmdr: string;
  system?: {
    name: string;
    id: BigInt;
    starPos: Extract<JournalEvent_BI, { event: "Location" }>["StarPos"];
  };
  station?: {
    name: string;
    id: BigInt;
    stationType: string;
    situation:
      | {
          type: "docking";
          pad: BigInt;
        }
      | {
          type: "vicinity";
        }
      | {
          type: "docked";
        };
  };
  vessel?:
    | {
        type: "Ship";
        name: string;
        id: BigInt;
        slef: LoadoutEvent_BI;
      }
    | {
        type: "SRV";
        // TODO
      }
    | {
        type: "OnFoot";
        // TODO
      };
};

/**
 * The gamestate essentially defines the "state" of the game. This is inferred by aggregating all events for a journal.
 * Do note that we turn off EDDN Emitting is on a Legacy Client.
 */
export class GameState {
  // We default to disabled. The GameState must be initialized with the eddn Settings
  #eddnSettings: z.infer<typeof EddnPreferencesZod> = { enabled: false };
  notifyEddnPrefsChanged(eddnPref: z.infer<typeof EddnPreferencesZod>): void {
    console.log({ eddnPref });
    this.#eddnSettings = eddnPref;
  }
  /**
   * The header MUST be present before using EDDN. If this is missing, we reject emitting to EDDN
   */
  #header: FileheaderEvent_BI | undefined;
  #cmdr: string | undefined;
  #eddnEmitter: EddnEmitter = new NoopEddnEmitter();
  #file: string;
  #cb: (ev: GameStateData | undefined, cmdr: string) => void;
  // The internal state. Once we load into the game this gets data
  #state: GameStateData | undefined;
  #loadGame: LoadGame | undefined;

  #batchedFssSignals: Record<string, FSSSignalDiscoveredEvent_BI[]> = {};

  constructor(
    file: string,
    eventCallback: (ev: GameStateData | undefined, cmdr: string) => void,
    private edpfVersion: string,
  ) {
    this.#file = file;
    this.#cb = eventCallback;
  }

  public get file() {
    return this.#file;
  }
  public get cmdr() {
    return this.#cmdr;
  }

  private emit() {
    // we clone here so that the receiver cannot modify the internal state
    const state = structuredClone(this.#state);
    this.#cb(state, this.#cmdr!);
  }

  private handleEvent(ev: JournalEvent_BI, allowEmitToEDDN: boolean) {
    //allowEmitToEDDN is true if, and only if, we are playing "live" data. Replaying the journal to reconcile the state does NOT emit to EDDN
    switch (ev.event) {
      case "Fileheader":
        this.#header = ev;
        // See also: https://github.com/EDCD/EDDN/blob/master/docs/Developers.md#gameversions-and-gamebuild
        // EDPF only serves Live (4.X), for both Odyssey and Horizons
        if (ev.Odyssey === true) {
          // We enable the EDDN Listener
          this.#eddnEmitter = new RealEddnEmitter(
            "https://eddn.edcd.io:4430",
            false,
          );
        }
        break;
      case "LoadGame":
        this.#loadGame = ev;
        break;
      case "Commander":
        this.#cmdr = ev.Name;
        if (!this.#state) {
          this.#state = {
            cmdr: ev.Name,
          };
        }
        this.emit();
        break;
      case "Location":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        this.#state.system = {
          name: ev.StarSystem,
          id: ev.SystemAddress,
          starPos: ev.StarPos,
        };
        // TODO: use this to determine if we're in Taxi, Docked, Multicrew
        if (ev.MarketID) {
          // We are docked
          this.#state.station = {
            stationType: ev.StationType!,
            situation: { type: "docked" },
            name: ev.StationName!,
            id: ev.MarketID,
          };
        }
        this.emit();
        break;
      case "Loadout":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        this.#state.vessel = {
          type: "Ship",
          id: ev.ShipID,
          name: ev.ShipName,
          slef: ev,
        };
        this.emit();
        break;
      case "FSDJump":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        this.#state.system = {
          name: ev.StarSystem,
          id: ev.SystemAddress,
          starPos: ev.StarPos,
        };
        delete this.#state.station;
        this.emit();
        break;
      case "Undocked":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        if (
          this.#state.station &&
          this.#state.station.situation.type === "docked"
        ) {
          this.#state.station.situation = {
            type: "vicinity",
          };
        }
        this.emit();
        return;
      case "SupercruiseEntry":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        delete this.#state.station;
        this.#state.system = {
          id: ev.SystemAddress,
          name: ev.StarSystem,
          starPos: this.#state.system!.starPos,
        };
        this.emit();
        break;
      case "DockingCancelled":
      case "DockingDenied":
      case "DockingGranted":
      case "Docked":
        if (!this.#state) {
          throw new Error("invalid state");
        }

        let situation: NonNullable<GameStateData["station"]>["situation"] = {
          type: "vicinity",
        };
        if (ev.event === "Docked") {
          situation = {
            type: "docked",
          };
        }
        if (ev.event === "DockingGranted") {
          situation = {
            type: "docking",
            pad: ev.LandingPad,
          };
        }

        this.#state.station = {
          id: ev.MarketID,
          name: ev.StationName,
          stationType: ev.StationType,
          situation,
        };
        this.emit();
        break;
      case "CarrierJump":
        if (!this.#state) {
          throw new Error("invalid state");
        }
        if (ev.Docked) {
          this.#state.system = {
            name: ev.StarSystem,
            id: ev.SystemAddress,
            starPos: ev.StarPos,
          };
          this.emit();
          break;
        }
    }
    // at this point the "internal" state is set. We now handle EDDN (if allowed and preconditions are met)
    if (
      this.#eddnSettings.enabled &&
      allowEmitToEDDN &&
      this.#cmdr &&
      this.#header &&
      this.#loadGame &&
      this.#state?.system
    ) {
      let eddnData:
        | undefined
        | { message: object | undefined; $schemaRef: string };
      const header = makeEddnHeader(this.edpfVersion, this.#cmdr, this.#header);

      switch (ev.event) {
        case "Docked":
        case "FSDJump":
        case "Scan":
        case "Location":
        case "SAASignalsFound":
        case "CarrierJump":
        case "CodexEntry":
          eddnData = {
            message: extractAndStripJournal(
              ev,
              this.#state.system,
              this.#loadGame,
            ),
            $schemaRef: "https://eddn.edcd.io/schemas/journal/1" as const,
          };
          break;
        case "DockingDenied":
          eddnData = {
            message: stripDockingDeniedEvent(ev, this.#loadGame),
            $schemaRef: "https://eddn.edcd.io/schemas/dockingdenied/1" as const,
          };
          break;
        case "DockingGranted":
          eddnData = {
            message: stripDockingGrantedEvent(ev, this.#loadGame),
            $schemaRef:
              "https://eddn.edcd.io/schemas/dockinggranted/1" as const,
          };
          break;
        case "ApproachSettlement":
          eddnData = {
            $schemaRef:
              "https://eddn.edcd.io/schemas/approachsettlement/1" as const,
            message: stripApproachSettlementEvent(
              ev,
              this.#state.system,
              this.#loadGame,
            ),
          };
          break;
        case "FSSAllBodiesFound":
          eddnData = {
            $schemaRef:
              "https://eddn.edcd.io/schemas/fssallbodiesfound/1" as const,
            message: stripFssAllBodiesFound(
              ev,
              this.#state.system,
              this.#loadGame,
            ),
          };
          break;
        case "FSSBodySignals":
          eddnData = {
            $schemaRef:
              "https://eddn.edcd.io/schemas/fssbodysignals/1" as const,
            message: stripFssBodySignals(
              ev,
              this.#state.system,
              this.#loadGame,
            ),
          };
          break;
        case "FSSDiscoveryScan":
          eddnData = {
            $schemaRef:
              "https://eddn.edcd.io/schemas/fssdiscoveryscan/1" as const,
            message: stripFssDiscoveryScan(
              ev,
              this.#state.system,
              this.#loadGame,
            ),
          };
          break;
        case "FSSSignalDiscovered":
          // this is a bit different -> we do batching for Body Signals
          const systemId = ev.SystemAddress.toString();
          if (!this.#batchedFssSignals[systemId]) {
            this.#batchedFssSignals[systemId] = [];
          }
          this.#batchedFssSignals[systemId].push(ev);
      }
      if (eddnData && eddnData.message) {
        const entirePayload = {
          message: eddnData.message!,
          $schemaRef: eddnData.$schemaRef,
          header,
        };
        this.#eddnEmitter.emit(entirePayload);
      }

      if (
        this.#state.system &&
        ev.event !== "FSSSignalDiscovered" &&
        ev.event !== "Scan" &&
        ev.event !== "ScanBaryCentre" &&
        ev.event !== "Friends" &&
        ev.event !== "ReceiveText" &&
        ev.event !== "Music"
      ) {
        // We use this to determine that it is time to send FSSSignalDiscovered events
        const items =
          this.#batchedFssSignals[this.#state.system.id.toString()] ?? [];
        this.#batchedFssSignals = {};
        // validate that all states have the same System ID
        const sameSystemAddress =
          new Set(items.map((sys) => sys.SystemAddress)).size === 1;
        // assert that the state we have is the same sys address
        const hasItemsWithDifferentSystemAddress =
          items.filter((f) => f.SystemAddress !== this.#state?.system?.id)
            .length > 0;

        if (
          items.length > 0 &&
          sameSystemAddress &&
          !hasItemsWithDifferentSystemAddress
        ) {
          // if here, all items are in the same location and in the current system. Time to build the payload
          const message = stripAndExtractFSSSignalDiscovered(
            items,
            this.#state.system,
            this.#loadGame,
          );
          if (message) {
            this.#eddnEmitter.emit({
              $schemaRef:
                "https://eddn.edcd.io/schemas/fsssignaldiscovered/1" as const,
              header,
              message,
            });
          }
        }
      }
    }
  }

  public notifyAboutEvents(evs: JournalEvent_BI[], allowEmitToEDDN = false) {
    for (const ev of evs) {
      this.handleEvent(ev, allowEmitToEDDN);
    }
  }

  public static fromInitialState(
    evs: JournalEvent_BI[],
    file: string,
    eventCallback: (ev: GameStateData | undefined, cmdr: string) => void,
    edpfVersion: string,
  ) {
    const state = new GameState(file, eventCallback, edpfVersion);
    evs.forEach((e) => state.handleEvent(e, false));
    return state;
  }
}

/**
 * @returns true if both states are equal, false if there is any difference
 */
export function eqUiState(
  a: GameStateData | undefined,
  b: GameStateData | undefined,
): boolean {
  if ((!a && b) || (a && !b)) return false;
  if (!a && !b) return true;
  if (!a || !b) throw ""; // will never happen, just to please TS
  return JSON.stringify(a) === JSON.stringify(b);
}
